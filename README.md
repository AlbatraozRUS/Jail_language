# Тюремный язык
## Преамбула
Данный проект является заключительным в рамках курса 1 семестра по промышленному программированию. Тюремный язык - язык программирования высокого уровня, его синтаксис имеет общие моменты с `C`, но тем не менее обладает другими ключевыми словами и упрощенным функционалом. На вход программа принимает `.txt` файл, который обрабатывается рекурсивным алгоритмом и создает абстрактное синтаксическое дерево. В дополнение, хотел бы заметить, что стандарт дерева является общим с моими сокурсниками, что улучшает универсальность и позволяет производить обмен между нашими языками. Далее, на основе AST создается выходной файл в формате моего ассемблера, который запускается на соответствующем эмуляторе (Более подробно о `Процессоре` вы можете посмотреть [здесь](https://github.com/AlbatraozRUS/Soft_Processor)). 

## Ключевые слова
|Команда                |      Действие         |
|:----------------------|:---------------------:|
|`Залететь на зону     `| Обьявление функции    |
|`По какой статье      `| Считать переменную    |
|`Кто по жизни         `| Распечатать переменную|
|`На какой стул сядешь `| Конструкция `if`      |
|`Погонять             `| Конструкция `while`   |
|`Откинулся            `| `return`              |
|`Базар окончен        `| Окончание кода        |

Данные ключевые слова можно изменять по своему желанию в соответствующем [файле](https://github.com/AlbatraozRUS/Language/blob/master/OPes.h)

## Пример входного файла
```
Бесконечно = 3
Никто      = 0

Залететь на зону главный ()
{
По какой статье ( Авторитет )

По какой статье ( Бродяга )

По какой статье ( Сосунок )

На какой стул сядешь ( Авторитет = 0 )
    стул 1:

    На какой стул сядешь ( Бродяга = 0 )
        стул 1:

        На какой стул сядешь ( Сосунок = 0 )
            стул 1:

            Кто по жизни ( Бесконечно )
            }

            стул 2:

            Кто по жизни ( Никто )
            }
        }

        стул 2:

        Лох = (0 - 1) * Сосунок / Бродяга
        Кто по жизни ( Лох )
        }
    }

    стул 2:
    Дебил = Бродяга * Бродяга - 4 * Авторитет * Сосунок
    Дебил = корешок ( Дебил )

    Первый = ((0 - 1) * Бродяга + Дебил ) / (2 * Авторитет )
    Второй = ((0 - 1) * Бродяга - Дебил ) / (2 * Авторитет )

    Кто по жизни ( Первый )
    Кто по жизни ( Второй )
    }
Откинулся ( Никто )
}
Базар окончен!
```
Аналогичный код на `C`:
``` C
int Бесконечно = 3;
int Никто = 0;

int Главный()
{
int Авторитет = 0;
scanf("%d", &Авторитет);

int Бродяга = 0;
scanf("%d", &Бродяга);

int Сосунок = 0;
scanf("%d", &Сосунок);

if (Авторитет == 0){

    if (Бродяга == 0)
    {
        if (Сосунок == 0)
            printf("%d", Бесконечно);
        else
            printf("%d", Никто);         
    }
    else   
    {
        int Лох = -1 * Сосунок / Бродяга;
        printf("%d", Лох);        
    }
}
else
{
    int Дебил = Бродяга * Бродяга - 4 * Авторитет * Сосунок;
    Дебил = sqrt(Дебил);

    int Первый = (-1 * Бродяга + Дебил) / (2 * Авторитет);
    int Второй = (-1 * Бродяга - Дебил) / (2 * Авторитет);

    printf("%d", Первый);
    printf("%d", Второй);
}
return 0;
}
```

## Основные модули 
* [FrontEnd](https://github.com/AlbatraozRUS/Language/blob/master/Recursive%20descent.cpp) - преобразовывает текст программы в AST с использованием алгоритма рекурсивного спуска.
* [Обратный FrontEnd](https://github.com/AlbatraozRUS/Language/blob/master/FrontBack.cpp) - получает текстовый файл, в котором записано дерево по разработанному стандарту и восстанавливает текст программы.
* [BackEnd](https://github.com/AlbatraozRUS/Language/blob/master/Backend.cpp) - формирует на основе полученного дерева  текстовый файл с программой на собственной версии ассемблера для дальнейшего выполнения на эмуляторе.
* [Backend_x86](https://github.com/AlbatraozRUS/Compiler_x86_64) - Продолжение идеи этого проекта, получает на вход AST, а выходе получаем `ELF` файл.
## Пример абстрактного синтаксического дерева
![AST.png](https://github.com/AlbatraozRUS/Language/blob/master/Tree.jpg)
